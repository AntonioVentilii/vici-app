/* eslint-disable */

// @ts-nocheck

// This file was automatically generated by @caffeinelabs/bindgen@0.1.0.
// You should NOT make any changes in this file as it will be overwritten.
// Additionally, you should also exclude this file from your linter and/or formatter to prevent it from being checked or modified.

import {
	Actor,
	HttpAgent,
	type HttpAgentOptions,
	type ActorConfig,
	type Agent,
	type ActorSubclass
} from '@icp-sdk/core/agent';
import type { Principal } from '@icp-sdk/core/principal';
import { idlFactory, type _SERVICE } from './declarations/backend.did';
export interface Some<T> {
	__kind__: 'Some';
	value: T;
}
export interface None {
	__kind__: 'None';
}
export type Option<T> = Some<T> | None;
function some<T>(value: T): Some<T> {
	return {
		__kind__: 'Some',
		value: value
	};
}
function none(): None {
	return {
		__kind__: 'None'
	};
}
function isNone<T>(option: Option<T>): option is None {
	return option.__kind__ === 'None';
}
function isSome<T>(option: Option<T>): option is Some<T> {
	return option.__kind__ === 'Some';
}
function unwrap<T>(option: Option<T>): T {
	if (isNone(option)) {
		throw new Error('unwrap: none');
	}
	return option.value;
}
function candid_some<T>(value: T): [T] {
	return [value];
}
function candid_none<T>(): [] {
	return [];
}
function record_opt_to_undefined<T>(arg: T | null): T | undefined {
	return arg == null ? undefined : arg;
}
export class ExternalBlob {
	_blob?: Uint8Array<ArrayBuffer> | null;
	directURL: string;
	onProgress?: (percentage: number) => void = undefined;
	private constructor(directURL: string, blob: Uint8Array<ArrayBuffer> | null) {
		if (blob) {
			this._blob = blob;
		}
		this.directURL = directURL;
	}
	static fromURL(url: string): ExternalBlob {
		return new ExternalBlob(url, null);
	}
	static fromBytes(blob: Uint8Array<ArrayBuffer>): ExternalBlob {
		const url = URL.createObjectURL(
			new Blob([new Uint8Array(blob)], {
				type: 'application/octet-stream'
			})
		);
		return new ExternalBlob(url, blob);
	}
	public async getBytes(): Promise<Uint8Array<ArrayBuffer>> {
		if (this._blob) {
			return this._blob;
		}
		const response = await fetch(this.directURL);
		const blob = await response.blob();
		this._blob = new Uint8Array(await blob.arrayBuffer());
		return this._blob;
	}
	public getDirectURL(): string {
		return this.directURL;
	}
	public withUploadProgress(onProgress: (percentage: number) => void): ExternalBlob {
		this.onProgress = onProgress;
		return this;
	}
}
export interface AnalyticsDataPoint {
	oddsNo: number;
	volume: bigint;
	timestamp: Time;
	oddsYes: number;
}
export interface MarketDepthPosition {
	nickname: string;
	odds: number;
	user: Principal;
	positionType: PositionType;
	amount: bigint;
}
export type Time = bigint;
export interface Position {
	odds: number;
	createdAt: Time;
	positionType: PositionType;
	marketId: bigint;
	amount: bigint;
}
export interface WalletBalance {
	icp: bigint;
	ckUSDC: bigint;
}
export interface MarketSnapshot {
	id: bigint;
	categories: Array<string>;
	status: MarketStatus;
	invitedUsers: Array<Principal>;
	title: string;
	oddsNo: number;
	resolvedOutcome?: boolean;
	createdAt: Time;
	createdBy: Principal;
	description: string;
	expiration: Time;
	inviteOnly: boolean;
	oddsYes: number;
}
export interface Comment {
	id: bigint;
	content: string;
	createdAt: Time;
	user: Principal;
	marketId: bigint;
	isHidden: boolean;
}
export interface UserProfile {
	nickname: string;
	balance: bigint;
	createdAt: Time;
	lastLogin: Time;
	avatar: string;
}
export interface Transaction {
	id: bigint;
	transactionType: Variant_trade_deposit_payout;
	odds?: number;
	createdAt: Time;
	user: Principal;
	positionType?: PositionType;
	marketId?: bigint;
	amount: bigint;
}
export enum MarketStatus {
	resolved = 'resolved',
	closed = 'closed',
	open = 'open'
}
export enum PositionType {
	no = 'no',
	yes = 'yes'
}
export enum UserRole {
	admin = 'admin',
	user = 'user',
	guest = 'guest'
}
export enum Variant_trade_deposit_payout {
	trade = 'trade',
	deposit = 'deposit',
	payout = 'payout'
}
export interface backendInterface {
	addComment(marketId: bigint, content: string): Promise<bigint>;
	addFriend(friend: Principal): Promise<void>;
	assignCallerUserRole(user: Principal, role: UserRole): Promise<void>;
	createMarket(
		title: string,
		description: string,
		categories: Array<string>,
		expiration: Time,
		inviteOnly: boolean,
		invitedUsers: Array<Principal>
	): Promise<bigint>;
	createUserProfile(nickname: string, avatar: string): Promise<void>;
	depositFunds(amount: bigint): Promise<void>;
	getAllMarkets(): Promise<Array<MarketSnapshot>>;
	getCallerUserProfile(): Promise<UserProfile | null>;
	getCallerUserRole(): Promise<UserRole>;
	getFriends(): Promise<Array<Principal>>;
	getFriendsPositions(): Promise<Array<[Principal, Array<Position>]>>;
	getMarket(marketId: bigint): Promise<MarketSnapshot | null>;
	getMarketAnalytics(marketId: bigint): Promise<Array<AnalyticsDataPoint>>;
	getMarketComments(marketId: bigint): Promise<Array<Comment>>;
	getMarketDepth(marketId: bigint): Promise<Array<MarketDepthPosition>>;
	getMarketsByCategory(category: string): Promise<Array<MarketSnapshot>>;
	getUserPositions(): Promise<Array<Position>>;
	getUserProfile(user: Principal): Promise<UserProfile | null>;
	getUserTransactions(): Promise<Array<Transaction>>;
	getWalletBalance(): Promise<WalletBalance | null>;
	hideComment(commentId: bigint, marketId: bigint): Promise<void>;
	initializeAccessControl(): Promise<void>;
	isCallerAdmin(): Promise<boolean>;
	placePosition(marketId: bigint, positionType: PositionType, amount: bigint): Promise<void>;
	removeFriend(friend: Principal): Promise<void>;
	resolveMarket(marketId: bigint, outcome: boolean): Promise<void>;
	saveCallerUserProfile(profile: UserProfile): Promise<void>;
	updateLastLogin(): Promise<void>;
	updateMarketAnalytics(marketId: bigint): Promise<void>;
	withdrawFunds(amount: bigint): Promise<void>;
}
import type {
	MarketDepthPosition as _MarketDepthPosition,
	MarketSnapshot as _MarketSnapshot,
	MarketStatus as _MarketStatus,
	Position as _Position,
	PositionType as _PositionType,
	Time as _Time,
	Transaction as _Transaction,
	UserProfile as _UserProfile,
	UserRole as _UserRole,
	WalletBalance as _WalletBalance
} from './declarations/backend.did.d.ts';
export class Backend implements backendInterface {
	constructor(
		private actor: ActorSubclass<_SERVICE>,
		private _uploadFile: (file: ExternalBlob) => Promise<Uint8Array>,
		private _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>,
		private processError?: (error: unknown) => never
	) {}
	async addComment(arg0: bigint, arg1: string): Promise<bigint> {
		if (this.processError) {
			try {
				const result = await this.actor.addComment(arg0, arg1);
				return result;
			} catch (e) {
				this.processError(e);
				throw new Error('unreachable');
			}
		} else {
			const result = await this.actor.addComment(arg0, arg1);
			return result;
		}
	}
	async addFriend(arg0: Principal): Promise<void> {
		if (this.processError) {
			try {
				const result = await this.actor.addFriend(arg0);
				return result;
			} catch (e) {
				this.processError(e);
				throw new Error('unreachable');
			}
		} else {
			const result = await this.actor.addFriend(arg0);
			return result;
		}
	}
	async assignCallerUserRole(arg0: Principal, arg1: UserRole): Promise<void> {
		if (this.processError) {
			try {
				const result = await this.actor.assignCallerUserRole(
					arg0,
					to_candid_UserRole_n1(this._uploadFile, this._downloadFile, arg1)
				);
				return result;
			} catch (e) {
				this.processError(e);
				throw new Error('unreachable');
			}
		} else {
			const result = await this.actor.assignCallerUserRole(
				arg0,
				to_candid_UserRole_n1(this._uploadFile, this._downloadFile, arg1)
			);
			return result;
		}
	}
	async createMarket(
		arg0: string,
		arg1: string,
		arg2: Array<string>,
		arg3: Time,
		arg4: boolean,
		arg5: Array<Principal>
	): Promise<bigint> {
		if (this.processError) {
			try {
				const result = await this.actor.createMarket(arg0, arg1, arg2, arg3, arg4, arg5);
				return result;
			} catch (e) {
				this.processError(e);
				throw new Error('unreachable');
			}
		} else {
			const result = await this.actor.createMarket(arg0, arg1, arg2, arg3, arg4, arg5);
			return result;
		}
	}
	async createUserProfile(arg0: string, arg1: string): Promise<void> {
		if (this.processError) {
			try {
				const result = await this.actor.createUserProfile(arg0, arg1);
				return result;
			} catch (e) {
				this.processError(e);
				throw new Error('unreachable');
			}
		} else {
			const result = await this.actor.createUserProfile(arg0, arg1);
			return result;
		}
	}
	async depositFunds(arg0: bigint): Promise<void> {
		if (this.processError) {
			try {
				const result = await this.actor.depositFunds(arg0);
				return result;
			} catch (e) {
				this.processError(e);
				throw new Error('unreachable');
			}
		} else {
			const result = await this.actor.depositFunds(arg0);
			return result;
		}
	}
	async getAllMarkets(): Promise<Array<MarketSnapshot>> {
		if (this.processError) {
			try {
				const result = await this.actor.getAllMarkets();
				return from_candid_vec_n3(this._uploadFile, this._downloadFile, result);
			} catch (e) {
				this.processError(e);
				throw new Error('unreachable');
			}
		} else {
			const result = await this.actor.getAllMarkets();
			return from_candid_vec_n3(this._uploadFile, this._downloadFile, result);
		}
	}
	async getCallerUserProfile(): Promise<UserProfile | null> {
		if (this.processError) {
			try {
				const result = await this.actor.getCallerUserProfile();
				return from_candid_opt_n9(this._uploadFile, this._downloadFile, result);
			} catch (e) {
				this.processError(e);
				throw new Error('unreachable');
			}
		} else {
			const result = await this.actor.getCallerUserProfile();
			return from_candid_opt_n9(this._uploadFile, this._downloadFile, result);
		}
	}
	async getCallerUserRole(): Promise<UserRole> {
		if (this.processError) {
			try {
				const result = await this.actor.getCallerUserRole();
				return from_candid_UserRole_n10(this._uploadFile, this._downloadFile, result);
			} catch (e) {
				this.processError(e);
				throw new Error('unreachable');
			}
		} else {
			const result = await this.actor.getCallerUserRole();
			return from_candid_UserRole_n10(this._uploadFile, this._downloadFile, result);
		}
	}
	async getFriends(): Promise<Array<Principal>> {
		if (this.processError) {
			try {
				const result = await this.actor.getFriends();
				return result;
			} catch (e) {
				this.processError(e);
				throw new Error('unreachable');
			}
		} else {
			const result = await this.actor.getFriends();
			return result;
		}
	}
	async getFriendsPositions(): Promise<Array<[Principal, Array<Position>]>> {
		if (this.processError) {
			try {
				const result = await this.actor.getFriendsPositions();
				return from_candid_vec_n12(this._uploadFile, this._downloadFile, result);
			} catch (e) {
				this.processError(e);
				throw new Error('unreachable');
			}
		} else {
			const result = await this.actor.getFriendsPositions();
			return from_candid_vec_n12(this._uploadFile, this._downloadFile, result);
		}
	}
	async getMarket(arg0: bigint): Promise<MarketSnapshot | null> {
		if (this.processError) {
			try {
				const result = await this.actor.getMarket(arg0);
				return from_candid_opt_n19(this._uploadFile, this._downloadFile, result);
			} catch (e) {
				this.processError(e);
				throw new Error('unreachable');
			}
		} else {
			const result = await this.actor.getMarket(arg0);
			return from_candid_opt_n19(this._uploadFile, this._downloadFile, result);
		}
	}
	async getMarketAnalytics(arg0: bigint): Promise<Array<AnalyticsDataPoint>> {
		if (this.processError) {
			try {
				const result = await this.actor.getMarketAnalytics(arg0);
				return result;
			} catch (e) {
				this.processError(e);
				throw new Error('unreachable');
			}
		} else {
			const result = await this.actor.getMarketAnalytics(arg0);
			return result;
		}
	}
	async getMarketComments(arg0: bigint): Promise<Array<Comment>> {
		if (this.processError) {
			try {
				const result = await this.actor.getMarketComments(arg0);
				return result;
			} catch (e) {
				this.processError(e);
				throw new Error('unreachable');
			}
		} else {
			const result = await this.actor.getMarketComments(arg0);
			return result;
		}
	}
	async getMarketDepth(arg0: bigint): Promise<Array<MarketDepthPosition>> {
		if (this.processError) {
			try {
				const result = await this.actor.getMarketDepth(arg0);
				return from_candid_vec_n20(this._uploadFile, this._downloadFile, result);
			} catch (e) {
				this.processError(e);
				throw new Error('unreachable');
			}
		} else {
			const result = await this.actor.getMarketDepth(arg0);
			return from_candid_vec_n20(this._uploadFile, this._downloadFile, result);
		}
	}
	async getMarketsByCategory(arg0: string): Promise<Array<MarketSnapshot>> {
		if (this.processError) {
			try {
				const result = await this.actor.getMarketsByCategory(arg0);
				return from_candid_vec_n3(this._uploadFile, this._downloadFile, result);
			} catch (e) {
				this.processError(e);
				throw new Error('unreachable');
			}
		} else {
			const result = await this.actor.getMarketsByCategory(arg0);
			return from_candid_vec_n3(this._uploadFile, this._downloadFile, result);
		}
	}
	async getUserPositions(): Promise<Array<Position>> {
		if (this.processError) {
			try {
				const result = await this.actor.getUserPositions();
				return from_candid_vec_n14(this._uploadFile, this._downloadFile, result);
			} catch (e) {
				this.processError(e);
				throw new Error('unreachable');
			}
		} else {
			const result = await this.actor.getUserPositions();
			return from_candid_vec_n14(this._uploadFile, this._downloadFile, result);
		}
	}
	async getUserProfile(arg0: Principal): Promise<UserProfile | null> {
		if (this.processError) {
			try {
				const result = await this.actor.getUserProfile(arg0);
				return from_candid_opt_n9(this._uploadFile, this._downloadFile, result);
			} catch (e) {
				this.processError(e);
				throw new Error('unreachable');
			}
		} else {
			const result = await this.actor.getUserProfile(arg0);
			return from_candid_opt_n9(this._uploadFile, this._downloadFile, result);
		}
	}
	async getUserTransactions(): Promise<Array<Transaction>> {
		if (this.processError) {
			try {
				const result = await this.actor.getUserTransactions();
				return from_candid_vec_n23(this._uploadFile, this._downloadFile, result);
			} catch (e) {
				this.processError(e);
				throw new Error('unreachable');
			}
		} else {
			const result = await this.actor.getUserTransactions();
			return from_candid_vec_n23(this._uploadFile, this._downloadFile, result);
		}
	}
	async getWalletBalance(): Promise<WalletBalance | null> {
		if (this.processError) {
			try {
				const result = await this.actor.getWalletBalance();
				return from_candid_opt_n30(this._uploadFile, this._downloadFile, result);
			} catch (e) {
				this.processError(e);
				throw new Error('unreachable');
			}
		} else {
			const result = await this.actor.getWalletBalance();
			return from_candid_opt_n30(this._uploadFile, this._downloadFile, result);
		}
	}
	async hideComment(arg0: bigint, arg1: bigint): Promise<void> {
		if (this.processError) {
			try {
				const result = await this.actor.hideComment(arg0, arg1);
				return result;
			} catch (e) {
				this.processError(e);
				throw new Error('unreachable');
			}
		} else {
			const result = await this.actor.hideComment(arg0, arg1);
			return result;
		}
	}
	async initializeAccessControl(): Promise<void> {
		if (this.processError) {
			try {
				const result = await this.actor.initializeAccessControl();
				return result;
			} catch (e) {
				this.processError(e);
				throw new Error('unreachable');
			}
		} else {
			const result = await this.actor.initializeAccessControl();
			return result;
		}
	}
	async isCallerAdmin(): Promise<boolean> {
		if (this.processError) {
			try {
				const result = await this.actor.isCallerAdmin();
				return result;
			} catch (e) {
				this.processError(e);
				throw new Error('unreachable');
			}
		} else {
			const result = await this.actor.isCallerAdmin();
			return result;
		}
	}
	async placePosition(arg0: bigint, arg1: PositionType, arg2: bigint): Promise<void> {
		if (this.processError) {
			try {
				const result = await this.actor.placePosition(
					arg0,
					to_candid_PositionType_n31(this._uploadFile, this._downloadFile, arg1),
					arg2
				);
				return result;
			} catch (e) {
				this.processError(e);
				throw new Error('unreachable');
			}
		} else {
			const result = await this.actor.placePosition(
				arg0,
				to_candid_PositionType_n31(this._uploadFile, this._downloadFile, arg1),
				arg2
			);
			return result;
		}
	}
	async removeFriend(arg0: Principal): Promise<void> {
		if (this.processError) {
			try {
				const result = await this.actor.removeFriend(arg0);
				return result;
			} catch (e) {
				this.processError(e);
				throw new Error('unreachable');
			}
		} else {
			const result = await this.actor.removeFriend(arg0);
			return result;
		}
	}
	async resolveMarket(arg0: bigint, arg1: boolean): Promise<void> {
		if (this.processError) {
			try {
				const result = await this.actor.resolveMarket(arg0, arg1);
				return result;
			} catch (e) {
				this.processError(e);
				throw new Error('unreachable');
			}
		} else {
			const result = await this.actor.resolveMarket(arg0, arg1);
			return result;
		}
	}
	async saveCallerUserProfile(arg0: UserProfile): Promise<void> {
		if (this.processError) {
			try {
				const result = await this.actor.saveCallerUserProfile(arg0);
				return result;
			} catch (e) {
				this.processError(e);
				throw new Error('unreachable');
			}
		} else {
			const result = await this.actor.saveCallerUserProfile(arg0);
			return result;
		}
	}
	async updateLastLogin(): Promise<void> {
		if (this.processError) {
			try {
				const result = await this.actor.updateLastLogin();
				return result;
			} catch (e) {
				this.processError(e);
				throw new Error('unreachable');
			}
		} else {
			const result = await this.actor.updateLastLogin();
			return result;
		}
	}
	async updateMarketAnalytics(arg0: bigint): Promise<void> {
		if (this.processError) {
			try {
				const result = await this.actor.updateMarketAnalytics(arg0);
				return result;
			} catch (e) {
				this.processError(e);
				throw new Error('unreachable');
			}
		} else {
			const result = await this.actor.updateMarketAnalytics(arg0);
			return result;
		}
	}
	async withdrawFunds(arg0: bigint): Promise<void> {
		if (this.processError) {
			try {
				const result = await this.actor.withdrawFunds(arg0);
				return result;
			} catch (e) {
				this.processError(e);
				throw new Error('unreachable');
			}
		} else {
			const result = await this.actor.withdrawFunds(arg0);
			return result;
		}
	}
}
function from_candid_MarketDepthPosition_n21(
	_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>,
	_downloadFile: (file: Uint8Array) => Promise<ExternalBlob>,
	value: _MarketDepthPosition
): MarketDepthPosition {
	return from_candid_record_n22(_uploadFile, _downloadFile, value);
}
function from_candid_MarketSnapshot_n4(
	_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>,
	_downloadFile: (file: Uint8Array) => Promise<ExternalBlob>,
	value: _MarketSnapshot
): MarketSnapshot {
	return from_candid_record_n5(_uploadFile, _downloadFile, value);
}
function from_candid_MarketStatus_n6(
	_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>,
	_downloadFile: (file: Uint8Array) => Promise<ExternalBlob>,
	value: _MarketStatus
): MarketStatus {
	return from_candid_variant_n7(_uploadFile, _downloadFile, value);
}
function from_candid_PositionType_n17(
	_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>,
	_downloadFile: (file: Uint8Array) => Promise<ExternalBlob>,
	value: _PositionType
): PositionType {
	return from_candid_variant_n18(_uploadFile, _downloadFile, value);
}
function from_candid_Position_n15(
	_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>,
	_downloadFile: (file: Uint8Array) => Promise<ExternalBlob>,
	value: _Position
): Position {
	return from_candid_record_n16(_uploadFile, _downloadFile, value);
}
function from_candid_Transaction_n24(
	_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>,
	_downloadFile: (file: Uint8Array) => Promise<ExternalBlob>,
	value: _Transaction
): Transaction {
	return from_candid_record_n25(_uploadFile, _downloadFile, value);
}
function from_candid_UserRole_n10(
	_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>,
	_downloadFile: (file: Uint8Array) => Promise<ExternalBlob>,
	value: _UserRole
): UserRole {
	return from_candid_variant_n11(_uploadFile, _downloadFile, value);
}
function from_candid_opt_n19(
	_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>,
	_downloadFile: (file: Uint8Array) => Promise<ExternalBlob>,
	value: [] | [_MarketSnapshot]
): MarketSnapshot | null {
	return value.length === 0
		? null
		: from_candid_MarketSnapshot_n4(_uploadFile, _downloadFile, value[0]);
}
function from_candid_opt_n27(
	_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>,
	_downloadFile: (file: Uint8Array) => Promise<ExternalBlob>,
	value: [] | [number]
): number | null {
	return value.length === 0 ? null : value[0];
}
function from_candid_opt_n28(
	_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>,
	_downloadFile: (file: Uint8Array) => Promise<ExternalBlob>,
	value: [] | [_PositionType]
): PositionType | null {
	return value.length === 0
		? null
		: from_candid_PositionType_n17(_uploadFile, _downloadFile, value[0]);
}
function from_candid_opt_n29(
	_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>,
	_downloadFile: (file: Uint8Array) => Promise<ExternalBlob>,
	value: [] | [bigint]
): bigint | null {
	return value.length === 0 ? null : value[0];
}
function from_candid_opt_n30(
	_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>,
	_downloadFile: (file: Uint8Array) => Promise<ExternalBlob>,
	value: [] | [_WalletBalance]
): WalletBalance | null {
	return value.length === 0 ? null : value[0];
}
function from_candid_opt_n8(
	_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>,
	_downloadFile: (file: Uint8Array) => Promise<ExternalBlob>,
	value: [] | [boolean]
): boolean | null {
	return value.length === 0 ? null : value[0];
}
function from_candid_opt_n9(
	_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>,
	_downloadFile: (file: Uint8Array) => Promise<ExternalBlob>,
	value: [] | [_UserProfile]
): UserProfile | null {
	return value.length === 0 ? null : value[0];
}
function from_candid_record_n16(
	_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>,
	_downloadFile: (file: Uint8Array) => Promise<ExternalBlob>,
	value: {
		odds: number;
		createdAt: _Time;
		positionType: _PositionType;
		marketId: bigint;
		amount: bigint;
	}
): {
	odds: number;
	createdAt: Time;
	positionType: PositionType;
	marketId: bigint;
	amount: bigint;
} {
	return {
		odds: value.odds,
		createdAt: value.createdAt,
		positionType: from_candid_PositionType_n17(_uploadFile, _downloadFile, value.positionType),
		marketId: value.marketId,
		amount: value.amount
	};
}
function from_candid_record_n22(
	_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>,
	_downloadFile: (file: Uint8Array) => Promise<ExternalBlob>,
	value: {
		nickname: string;
		odds: number;
		user: Principal;
		positionType: _PositionType;
		amount: bigint;
	}
): {
	nickname: string;
	odds: number;
	user: Principal;
	positionType: PositionType;
	amount: bigint;
} {
	return {
		nickname: value.nickname,
		odds: value.odds,
		user: value.user,
		positionType: from_candid_PositionType_n17(_uploadFile, _downloadFile, value.positionType),
		amount: value.amount
	};
}
function from_candid_record_n25(
	_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>,
	_downloadFile: (file: Uint8Array) => Promise<ExternalBlob>,
	value: {
		id: bigint;
		transactionType:
			| {
					trade: null;
			  }
			| {
					deposit: null;
			  }
			| {
					payout: null;
			  };
		odds: [] | [number];
		createdAt: _Time;
		user: Principal;
		positionType: [] | [_PositionType];
		marketId: [] | [bigint];
		amount: bigint;
	}
): {
	id: bigint;
	transactionType: Variant_trade_deposit_payout;
	odds?: number;
	createdAt: Time;
	user: Principal;
	positionType?: PositionType;
	marketId?: bigint;
	amount: bigint;
} {
	return {
		id: value.id,
		transactionType: from_candid_variant_n26(_uploadFile, _downloadFile, value.transactionType),
		odds: record_opt_to_undefined(from_candid_opt_n27(_uploadFile, _downloadFile, value.odds)),
		createdAt: value.createdAt,
		user: value.user,
		positionType: record_opt_to_undefined(
			from_candid_opt_n28(_uploadFile, _downloadFile, value.positionType)
		),
		marketId: record_opt_to_undefined(
			from_candid_opt_n29(_uploadFile, _downloadFile, value.marketId)
		),
		amount: value.amount
	};
}
function from_candid_record_n5(
	_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>,
	_downloadFile: (file: Uint8Array) => Promise<ExternalBlob>,
	value: {
		id: bigint;
		categories: Array<string>;
		status: _MarketStatus;
		invitedUsers: Array<Principal>;
		title: string;
		oddsNo: number;
		resolvedOutcome: [] | [boolean];
		createdAt: _Time;
		createdBy: Principal;
		description: string;
		expiration: _Time;
		inviteOnly: boolean;
		oddsYes: number;
	}
): {
	id: bigint;
	categories: Array<string>;
	status: MarketStatus;
	invitedUsers: Array<Principal>;
	title: string;
	oddsNo: number;
	resolvedOutcome?: boolean;
	createdAt: Time;
	createdBy: Principal;
	description: string;
	expiration: Time;
	inviteOnly: boolean;
	oddsYes: number;
} {
	return {
		id: value.id,
		categories: value.categories,
		status: from_candid_MarketStatus_n6(_uploadFile, _downloadFile, value.status),
		invitedUsers: value.invitedUsers,
		title: value.title,
		oddsNo: value.oddsNo,
		resolvedOutcome: record_opt_to_undefined(
			from_candid_opt_n8(_uploadFile, _downloadFile, value.resolvedOutcome)
		),
		createdAt: value.createdAt,
		createdBy: value.createdBy,
		description: value.description,
		expiration: value.expiration,
		inviteOnly: value.inviteOnly,
		oddsYes: value.oddsYes
	};
}
function from_candid_tuple_n13(
	_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>,
	_downloadFile: (file: Uint8Array) => Promise<ExternalBlob>,
	value: [Principal, Array<_Position>]
): [Principal, Array<Position>] {
	return [value[0], from_candid_vec_n14(_uploadFile, _downloadFile, value[1])];
}
function from_candid_variant_n11(
	_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>,
	_downloadFile: (file: Uint8Array) => Promise<ExternalBlob>,
	value:
		| {
				admin: null;
		  }
		| {
				user: null;
		  }
		| {
				guest: null;
		  }
): UserRole {
	return 'admin' in value
		? UserRole.admin
		: 'user' in value
			? UserRole.user
			: 'guest' in value
				? UserRole.guest
				: value;
}
function from_candid_variant_n18(
	_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>,
	_downloadFile: (file: Uint8Array) => Promise<ExternalBlob>,
	value:
		| {
				no: null;
		  }
		| {
				yes: null;
		  }
): PositionType {
	return 'no' in value ? PositionType.no : 'yes' in value ? PositionType.yes : value;
}
function from_candid_variant_n26(
	_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>,
	_downloadFile: (file: Uint8Array) => Promise<ExternalBlob>,
	value:
		| {
				trade: null;
		  }
		| {
				deposit: null;
		  }
		| {
				payout: null;
		  }
): Variant_trade_deposit_payout {
	return 'trade' in value
		? Variant_trade_deposit_payout.trade
		: 'deposit' in value
			? Variant_trade_deposit_payout.deposit
			: 'payout' in value
				? Variant_trade_deposit_payout.payout
				: value;
}
function from_candid_variant_n7(
	_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>,
	_downloadFile: (file: Uint8Array) => Promise<ExternalBlob>,
	value:
		| {
				resolved: null;
		  }
		| {
				closed: null;
		  }
		| {
				open: null;
		  }
): MarketStatus {
	return 'resolved' in value
		? MarketStatus.resolved
		: 'closed' in value
			? MarketStatus.closed
			: 'open' in value
				? MarketStatus.open
				: value;
}
function from_candid_vec_n12(
	_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>,
	_downloadFile: (file: Uint8Array) => Promise<ExternalBlob>,
	value: Array<[Principal, Array<_Position>]>
): Array<[Principal, Array<Position>]> {
	return value.map((x) => from_candid_tuple_n13(_uploadFile, _downloadFile, x));
}
function from_candid_vec_n14(
	_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>,
	_downloadFile: (file: Uint8Array) => Promise<ExternalBlob>,
	value: Array<_Position>
): Array<Position> {
	return value.map((x) => from_candid_Position_n15(_uploadFile, _downloadFile, x));
}
function from_candid_vec_n20(
	_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>,
	_downloadFile: (file: Uint8Array) => Promise<ExternalBlob>,
	value: Array<_MarketDepthPosition>
): Array<MarketDepthPosition> {
	return value.map((x) => from_candid_MarketDepthPosition_n21(_uploadFile, _downloadFile, x));
}
function from_candid_vec_n23(
	_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>,
	_downloadFile: (file: Uint8Array) => Promise<ExternalBlob>,
	value: Array<_Transaction>
): Array<Transaction> {
	return value.map((x) => from_candid_Transaction_n24(_uploadFile, _downloadFile, x));
}
function from_candid_vec_n3(
	_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>,
	_downloadFile: (file: Uint8Array) => Promise<ExternalBlob>,
	value: Array<_MarketSnapshot>
): Array<MarketSnapshot> {
	return value.map((x) => from_candid_MarketSnapshot_n4(_uploadFile, _downloadFile, x));
}
function to_candid_PositionType_n31(
	_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>,
	_downloadFile: (file: Uint8Array) => Promise<ExternalBlob>,
	value: PositionType
): _PositionType {
	return to_candid_variant_n32(_uploadFile, _downloadFile, value);
}
function to_candid_UserRole_n1(
	_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>,
	_downloadFile: (file: Uint8Array) => Promise<ExternalBlob>,
	value: UserRole
): _UserRole {
	return to_candid_variant_n2(_uploadFile, _downloadFile, value);
}
function to_candid_variant_n2(
	_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>,
	_downloadFile: (file: Uint8Array) => Promise<ExternalBlob>,
	value: UserRole
):
	| {
			admin: null;
	  }
	| {
			user: null;
	  }
	| {
			guest: null;
	  } {
	return value == UserRole.admin
		? {
				admin: null
			}
		: value == UserRole.user
			? {
					user: null
				}
			: value == UserRole.guest
				? {
						guest: null
					}
				: value;
}
function to_candid_variant_n32(
	_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>,
	_downloadFile: (file: Uint8Array) => Promise<ExternalBlob>,
	value: PositionType
):
	| {
			no: null;
	  }
	| {
			yes: null;
	  } {
	return value == PositionType.no
		? {
				no: null
			}
		: value == PositionType.yes
			? {
					yes: null
				}
			: value;
}
export interface CreateActorOptions {
	agent?: Agent;
	agentOptions?: HttpAgentOptions;
	actorOptions?: ActorConfig;
	processError?: (error: unknown) => never;
}
export function createActor(
	canisterId: string,
	_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>,
	_downloadFile: (file: Uint8Array) => Promise<ExternalBlob>,
	options: CreateActorOptions = {}
): Backend {
	const agent =
		options.agent ||
		HttpAgent.createSync({
			...options.agentOptions
		});
	if (options.agent && options.agentOptions) {
		console.warn(
			'Detected both agent and agentOptions passed to createActor. Ignoring agentOptions and proceeding with the provided agent.'
		);
	}
	const actor = Actor.createActor<_SERVICE>(idlFactory, {
		agent,
		canisterId: canisterId,
		...options.actorOptions
	});
	return new Backend(actor, _uploadFile, _downloadFile, options.processError);
}
