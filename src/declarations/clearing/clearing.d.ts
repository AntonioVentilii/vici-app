/* eslint-disable */

// @ts-nocheck

// This file was automatically generated by @icp-sdk/bindgen@0.1.2.
// You should NOT make any changes in this file as it will be overwritten.
// Additionally, you should also exclude this file from your linter and/or formatter to prevent it from being checked or modified.

import type { ActorMethod } from '@icp-sdk/core/agent';
import type { IDL } from '@icp-sdk/core/candid';
import type { Principal } from '@icp-sdk/core/principal';

export type AcceptPositionTransferResult = { Ok: boolean } | { Err: TradeError };
export type Asset = { Icrc: Principal };
export type CommonError =
	| { Internal: string }
	| { MathOverflow: null }
	| { Unauthorized: null }
	| { RegistryNotSet: null };
export type DepositCollateralError = { MathOverflow: null } | { Ledger: LedgerError };
export interface DepositCollateralParams {
	deposit_id: string;
	asset: Asset;
	amount: bigint;
}
export type DepositCollateralResult = { Ok: null } | { Err: DepositCollateralError };
export interface FreezePositionForTransferParams {
	series_id: string;
	user: Principal;
	transfer_id: string;
}
export interface GetMarginAccountParams {
	refresh: [] | [boolean];
}
export type GetMarginAccountResult = { Ok: MarginAccount } | { Err: MarginAccountError };
export interface GetPositionParams {
	series_id: string;
}
export type LedgerError =
	| { TransferError: string }
	| { InsufficientBalance: { balance: bigint; required: bigint } }
	| { MathOverflow: null }
	| { CallError: { method: string; code: number; message: string } }
	| { UnsupportedLedger: null };
export interface MarginAccount {
	required_margin: bigint;
	user: Principal;
	balances: Array<[Asset, bigint]>;
}
export type MarginAccountError =
	| { NoMarginAccountFound: null }
	| { MathOverflow: null }
	| { Ledger: LedgerError };
export type PayoffType = { Put: null } | { Binary: null } | { Call: null };
export interface Position {
	series_id: string;
	net_qty: bigint;
	user: Principal;
	locked_collateral: bigint;
}
export interface PositionProof {
	qty: bigint;
	signature: Uint8Array;
	series_id: string;
	user: Principal;
	transfer_id: string;
	clearing_id: Principal;
}
export interface Series {
	title: string;
	strike: [] | [bigint];
	creator: Principal;
	payoff_type: PayoffType;
	series_id: string;
	settlement_asset: SettlementAsset;
	underlying: string;
	description: string;
	expiry: bigint;
	oracle_source: string;
}
export interface SettleSeriesParams {
	series_id: string;
	settlement_price: bigint;
}
export type SettleSeriesResult = { Ok: null } | { Err: SettlementError };
export type SettlementAsset = { Icp: null } | { CkUsdc: null };
export type SettlementError =
	| { UnsupportedSettlementAsset: null }
	| { MathOverflow: null }
	| { Ledger: LedgerError }
	| { Common: CommonError };
export interface SubmitMatchedTradeParams {
	qty: bigint;
	trade_id: string;
	series_id: string;
	seller: Principal;
	buyer: Principal;
	price: bigint;
}
export type SubmitMatchedTradeResult = { Ok: boolean } | { Err: TradeError };
export type TradeError =
	| { RegistryError: string }
	| {
			InsufficientMargin: {
				balance: bigint;
				user: Principal;
				required: bigint;
			};
	  }
	| { SeriesNotFound: string }
	| { Common: CommonError };
export type WithdrawCollateralError =
	| {
			InsufficientExcessMargin: { requested: bigint; current: bigint };
	  }
	| { MathOverflow: null }
	| { Ledger: LedgerError };
export interface WithdrawCollateralParams {
	asset: Asset;
	withdrawal_id: string;
	amount: bigint;
}
export type WithdrawCollateralResult = { Ok: null } | { Err: WithdrawCollateralError };
export interface _SERVICE {
	/**
	 * Accepts a position transfer from another clearing canister.
	 *
	 * This method validates the series and increases the target user's position based on the provided
	 * proof. This method is gated to canister controllers.
	 */
	accept_position_transfer: ActorMethod<[PositionProof], AcceptPositionTransferResult>;
	/**
	 * Deposits collateral into the user's margin account.
	 *
	 * This is a multi-phase operation:
	 * 1. Building a [`DepositPlan`] for idempotency.
	 * 2. Executing the asynchronous ledger transfer (`transfer_from`).
	 * 3. Finalising the internal margin account balances.
	 *
	 * # Arguments
	 * * `params` - The deposit details including amount, asset, and a unique deposit ID.
	 *
	 * # Returns
	 * * [`DepositCollateralResult::Ok`] if the deposit was successfully planned or executed.
	 * * [`DepositCollateralResult::Err`] if the asset is unsupported or a transfer error occurs.
	 */
	deposit_collateral: ActorMethod<[DepositCollateralParams], DepositCollateralResult>;
	/**
	 * Freezes a user's position to prepare it for transfer to another clearing canister.
	 *
	 * Once frozen, the position is removed from active state and a [`PositionProof`] is issued.
	 * This method is gated to canister controllers.
	 */
	freeze_position_for_transfer: ActorMethod<
		[FreezePositionForTransferParams],
		[] | [PositionProof]
	>;
	/**
	 * Retrieves the current user's margin account details, optionally refreshing balances.
	 *
	 * # Arguments
	 * * `params` - Includes an optional `refresh` flag to trigger external ledger checks.
	 */
	get_margin_account: ActorMethod<[GetMarginAccountParams], GetMarginAccountResult>;
	/**
	 * Retrieves the current user's margin account details (query only).
	 *
	 * This does not refresh balances from external ledgers.
	 */
	get_margin_account_query: ActorMethod<[], GetMarginAccountResult>;
	/**
	 * Retrieves a specific position for the caller.
	 */
	get_position: ActorMethod<[GetPositionParams], [] | [Position]>;
	/**
	 * Retrieves all open positions for the caller.
	 */
	get_positions: ActorMethod<[], Array<[string, Position]>>;
	/**
	 * Returns a list of all derivative series currently cached in the clearing canister.
	 */
	list_series: ActorMethod<[], Array<Series>>;
	/**
	 * Sets the principal of the Series Registry canister.
	 *
	 * This principal is used to discover and validate derivative series.
	 * This method is gated to canister controllers.
	 */
	set_registry_canister: ActorMethod<[Principal], undefined>;
	/**
	 * Settles a derivative series at a specific price.
	 *
	 * This is a complex background operation consisting of:
	 * 1. Creating or resuming a [`SettlementPlan`].
	 * 2. Collecting collateral from users with net losses.
	 * 3. Paying out collateral to users with net profits.
	 * 4. Finalising internal margin account balances and releasing locked collateral.
	 *
	 * This method is gated to canister controllers and is intended to be called by an off-chain oracle
	 * or automation.
	 */
	settle_series: ActorMethod<[SettleSeriesParams], SettleSeriesResult>;
	/**
	 * Submits a matched trade from an exchange for clearing.
	 *
	 * This method validates the series registration, calculates margin requirements,
	 * checks for sufficient collateral, and updates the positions of both buyer and seller.
	 *
	 * # Arguments
	 * * `params` - The trade details including ID, series, buyer, seller, quantity, and price.
	 *
	 * # Returns
	 * * [`SubmitMatchedTradeResult::Ok(true)`] if the trade was successfully processed or was a
	 * duplicate.
	 * * [`SubmitMatchedTradeResult::Err`] if margin is insufficient or another error occurs.
	 */
	submit_matched_trade: ActorMethod<[SubmitMatchedTradeParams], SubmitMatchedTradeResult>;
	/**
	 * Withdraws collateral from the user's margin account to an external address.
	 *
	 * This is a multi-phase operation:
	 * 1. Building a [`WithdrawalPlan`] for idempotency.
	 * 2. Reserving the internal balance to prevent double-spending or risk violations.
	 * 3. Executing the asynchronous ledger transfer (`transfer`).
	 * 4. Finalising the plan status.
	 *
	 * # Arguments
	 * * `params` - The withdrawal details including amount, asset, and a unique withdrawal ID.
	 *
	 * # Returns
	 * * [`WithdrawalCollateralResult::Ok`] if the withdrawal was successfully planned or executed.
	 * * [`WithdrawalCollateralResult::Err`] if margin is insufficient or a transfer error occurs.
	 */
	withdraw_collateral: ActorMethod<[WithdrawCollateralParams], WithdrawCollateralResult>;
}
export declare const idlService: IDL.ServiceClass;
export declare const idlInitArgs: IDL.Type[];
export declare const idlFactory: IDL.InterfaceFactory;
export declare const init: (args: { IDL: typeof IDL }) => IDL.Type[];
