/* eslint-disable */

// @ts-nocheck

// This file was automatically generated by @icp-sdk/bindgen@0.1.2.
// You should NOT make any changes in this file as it will be overwritten.
// Additionally, you should also exclude this file from your linter and/or formatter to prevent it from being checked or modified.

import { IDL } from '@icp-sdk/core/candid';

export const PositionProof = IDL.Record({
	qty: IDL.Int,
	signature: IDL.Vec(IDL.Nat8),
	series_id: IDL.Text,
	user: IDL.Principal,
	transfer_id: IDL.Text,
	clearing_id: IDL.Principal
});
export const CommonError = IDL.Variant({
	Internal: IDL.Text,
	MathOverflow: IDL.Null,
	Unauthorized: IDL.Null,
	RegistryNotSet: IDL.Null
});
export const TradeError = IDL.Variant({
	RegistryError: IDL.Text,
	InsufficientMargin: IDL.Record({
		balance: IDL.Nat,
		user: IDL.Principal,
		required: IDL.Nat
	}),
	SeriesNotFound: IDL.Text,
	Common: CommonError
});
export const AcceptPositionTransferResult = IDL.Variant({
	Ok: IDL.Bool,
	Err: TradeError
});
export const Asset = IDL.Variant({ Icrc: IDL.Principal });
export const DepositCollateralParams = IDL.Record({
	deposit_id: IDL.Text,
	asset: Asset,
	amount: IDL.Nat
});
export const LedgerError = IDL.Variant({
	TransferError: IDL.Text,
	InsufficientBalance: IDL.Record({
		balance: IDL.Nat,
		required: IDL.Nat
	}),
	MathOverflow: IDL.Null,
	CallError: IDL.Record({
		method: IDL.Text,
		code: IDL.Int32,
		message: IDL.Text
	}),
	UnsupportedLedger: IDL.Null
});
export const DepositCollateralError = IDL.Variant({
	MathOverflow: IDL.Null,
	Ledger: LedgerError
});
export const DepositCollateralResult = IDL.Variant({
	Ok: IDL.Null,
	Err: DepositCollateralError
});
export const FreezePositionForTransferParams = IDL.Record({
	series_id: IDL.Text,
	user: IDL.Principal,
	transfer_id: IDL.Text
});
export const GetMarginAccountParams = IDL.Record({
	refresh: IDL.Opt(IDL.Bool)
});
export const MarginAccount = IDL.Record({
	required_margin: IDL.Nat,
	user: IDL.Principal,
	balances: IDL.Vec(IDL.Tuple(Asset, IDL.Nat))
});
export const MarginAccountError = IDL.Variant({
	NoMarginAccountFound: IDL.Null,
	MathOverflow: IDL.Null,
	Ledger: LedgerError
});
export const GetMarginAccountResult = IDL.Variant({
	Ok: MarginAccount,
	Err: MarginAccountError
});
export const GetPositionParams = IDL.Record({ series_id: IDL.Text });
export const Position = IDL.Record({
	series_id: IDL.Text,
	net_qty: IDL.Int,
	user: IDL.Principal,
	locked_collateral: IDL.Nat
});
export const PayoffType = IDL.Variant({
	Put: IDL.Null,
	Binary: IDL.Null,
	Call: IDL.Null
});
export const SettlementAsset = IDL.Variant({
	Icp: IDL.Null,
	CkUsdc: IDL.Null
});
export const Series = IDL.Record({
	title: IDL.Text,
	strike: IDL.Opt(IDL.Nat64),
	creator: IDL.Principal,
	payoff_type: PayoffType,
	series_id: IDL.Text,
	settlement_asset: SettlementAsset,
	underlying: IDL.Text,
	description: IDL.Text,
	expiry: IDL.Nat64,
	oracle_source: IDL.Text
});
export const SettleSeriesParams = IDL.Record({
	series_id: IDL.Text,
	settlement_price: IDL.Nat64
});
export const SettlementError = IDL.Variant({
	UnsupportedSettlementAsset: IDL.Null,
	MathOverflow: IDL.Null,
	Ledger: LedgerError,
	Common: CommonError
});
export const SettleSeriesResult = IDL.Variant({
	Ok: IDL.Null,
	Err: SettlementError
});
export const SubmitMatchedTradeParams = IDL.Record({
	qty: IDL.Int,
	trade_id: IDL.Text,
	series_id: IDL.Text,
	seller: IDL.Principal,
	buyer: IDL.Principal,
	price: IDL.Nat64
});
export const SubmitMatchedTradeResult = IDL.Variant({
	Ok: IDL.Bool,
	Err: TradeError
});
export const WithdrawCollateralParams = IDL.Record({
	asset: Asset,
	withdrawal_id: IDL.Text,
	amount: IDL.Nat
});
export const WithdrawCollateralError = IDL.Variant({
	InsufficientExcessMargin: IDL.Record({
		requested: IDL.Nat,
		current: IDL.Nat
	}),
	MathOverflow: IDL.Null,
	Ledger: LedgerError
});
export const WithdrawCollateralResult = IDL.Variant({
	Ok: IDL.Null,
	Err: WithdrawCollateralError
});

export const idlService = IDL.Service({
	accept_position_transfer: IDL.Func([PositionProof], [AcceptPositionTransferResult], []),
	deposit_collateral: IDL.Func([DepositCollateralParams], [DepositCollateralResult], []),
	freeze_position_for_transfer: IDL.Func(
		[FreezePositionForTransferParams],
		[IDL.Opt(PositionProof)],
		[]
	),
	get_margin_account: IDL.Func([GetMarginAccountParams], [GetMarginAccountResult], []),
	get_margin_account_query: IDL.Func([], [GetMarginAccountResult], ['query']),
	get_position: IDL.Func([GetPositionParams], [IDL.Opt(Position)], ['query']),
	get_positions: IDL.Func([], [IDL.Vec(IDL.Tuple(IDL.Text, Position))], ['query']),
	list_series: IDL.Func([], [IDL.Vec(Series)], ['query']),
	set_registry_canister: IDL.Func([IDL.Principal], [], []),
	settle_series: IDL.Func([SettleSeriesParams], [SettleSeriesResult], []),
	submit_matched_trade: IDL.Func([SubmitMatchedTradeParams], [SubmitMatchedTradeResult], []),
	withdraw_collateral: IDL.Func([WithdrawCollateralParams], [WithdrawCollateralResult], [])
});

export const idlInitArgs = [];

export const idlFactory = ({ IDL }) => {
	const PositionProof = IDL.Record({
		qty: IDL.Int,
		signature: IDL.Vec(IDL.Nat8),
		series_id: IDL.Text,
		user: IDL.Principal,
		transfer_id: IDL.Text,
		clearing_id: IDL.Principal
	});
	const CommonError = IDL.Variant({
		Internal: IDL.Text,
		MathOverflow: IDL.Null,
		Unauthorized: IDL.Null,
		RegistryNotSet: IDL.Null
	});
	const TradeError = IDL.Variant({
		RegistryError: IDL.Text,
		InsufficientMargin: IDL.Record({
			balance: IDL.Nat,
			user: IDL.Principal,
			required: IDL.Nat
		}),
		SeriesNotFound: IDL.Text,
		Common: CommonError
	});
	const AcceptPositionTransferResult = IDL.Variant({
		Ok: IDL.Bool,
		Err: TradeError
	});
	const Asset = IDL.Variant({ Icrc: IDL.Principal });
	const DepositCollateralParams = IDL.Record({
		deposit_id: IDL.Text,
		asset: Asset,
		amount: IDL.Nat
	});
	const LedgerError = IDL.Variant({
		TransferError: IDL.Text,
		InsufficientBalance: IDL.Record({
			balance: IDL.Nat,
			required: IDL.Nat
		}),
		MathOverflow: IDL.Null,
		CallError: IDL.Record({
			method: IDL.Text,
			code: IDL.Int32,
			message: IDL.Text
		}),
		UnsupportedLedger: IDL.Null
	});
	const DepositCollateralError = IDL.Variant({
		MathOverflow: IDL.Null,
		Ledger: LedgerError
	});
	const DepositCollateralResult = IDL.Variant({
		Ok: IDL.Null,
		Err: DepositCollateralError
	});
	const FreezePositionForTransferParams = IDL.Record({
		series_id: IDL.Text,
		user: IDL.Principal,
		transfer_id: IDL.Text
	});
	const GetMarginAccountParams = IDL.Record({ refresh: IDL.Opt(IDL.Bool) });
	const MarginAccount = IDL.Record({
		required_margin: IDL.Nat,
		user: IDL.Principal,
		balances: IDL.Vec(IDL.Tuple(Asset, IDL.Nat))
	});
	const MarginAccountError = IDL.Variant({
		NoMarginAccountFound: IDL.Null,
		MathOverflow: IDL.Null,
		Ledger: LedgerError
	});
	const GetMarginAccountResult = IDL.Variant({
		Ok: MarginAccount,
		Err: MarginAccountError
	});
	const GetPositionParams = IDL.Record({ series_id: IDL.Text });
	const Position = IDL.Record({
		series_id: IDL.Text,
		net_qty: IDL.Int,
		user: IDL.Principal,
		locked_collateral: IDL.Nat
	});
	const PayoffType = IDL.Variant({
		Put: IDL.Null,
		Binary: IDL.Null,
		Call: IDL.Null
	});
	const SettlementAsset = IDL.Variant({
		Icp: IDL.Null,
		CkUsdc: IDL.Null
	});
	const Series = IDL.Record({
		title: IDL.Text,
		strike: IDL.Opt(IDL.Nat64),
		creator: IDL.Principal,
		payoff_type: PayoffType,
		series_id: IDL.Text,
		settlement_asset: SettlementAsset,
		underlying: IDL.Text,
		description: IDL.Text,
		expiry: IDL.Nat64,
		oracle_source: IDL.Text
	});
	const SettleSeriesParams = IDL.Record({
		series_id: IDL.Text,
		settlement_price: IDL.Nat64
	});
	const SettlementError = IDL.Variant({
		UnsupportedSettlementAsset: IDL.Null,
		MathOverflow: IDL.Null,
		Ledger: LedgerError,
		Common: CommonError
	});
	const SettleSeriesResult = IDL.Variant({
		Ok: IDL.Null,
		Err: SettlementError
	});
	const SubmitMatchedTradeParams = IDL.Record({
		qty: IDL.Int,
		trade_id: IDL.Text,
		series_id: IDL.Text,
		seller: IDL.Principal,
		buyer: IDL.Principal,
		price: IDL.Nat64
	});
	const SubmitMatchedTradeResult = IDL.Variant({
		Ok: IDL.Bool,
		Err: TradeError
	});
	const WithdrawCollateralParams = IDL.Record({
		asset: Asset,
		withdrawal_id: IDL.Text,
		amount: IDL.Nat
	});
	const WithdrawCollateralError = IDL.Variant({
		InsufficientExcessMargin: IDL.Record({
			requested: IDL.Nat,
			current: IDL.Nat
		}),
		MathOverflow: IDL.Null,
		Ledger: LedgerError
	});
	const WithdrawCollateralResult = IDL.Variant({
		Ok: IDL.Null,
		Err: WithdrawCollateralError
	});

	return IDL.Service({
		accept_position_transfer: IDL.Func([PositionProof], [AcceptPositionTransferResult], []),
		deposit_collateral: IDL.Func([DepositCollateralParams], [DepositCollateralResult], []),
		freeze_position_for_transfer: IDL.Func(
			[FreezePositionForTransferParams],
			[IDL.Opt(PositionProof)],
			[]
		),
		get_margin_account: IDL.Func([GetMarginAccountParams], [GetMarginAccountResult], []),
		get_margin_account_query: IDL.Func([], [GetMarginAccountResult], ['query']),
		get_position: IDL.Func([GetPositionParams], [IDL.Opt(Position)], ['query']),
		get_positions: IDL.Func([], [IDL.Vec(IDL.Tuple(IDL.Text, Position))], ['query']),
		list_series: IDL.Func([], [IDL.Vec(Series)], ['query']),
		set_registry_canister: IDL.Func([IDL.Principal], [], []),
		settle_series: IDL.Func([SettleSeriesParams], [SettleSeriesResult], []),
		submit_matched_trade: IDL.Func([SubmitMatchedTradeParams], [SubmitMatchedTradeResult], []),
		withdraw_collateral: IDL.Func([WithdrawCollateralParams], [WithdrawCollateralResult], [])
	});
};

export const init = ({ IDL }) => {
	return [];
};
